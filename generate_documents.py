#!/usr/bin/env python3

import click
import os
import json
import random
import glob
import shutil
from typing import List, Dict, Any
from ai_providers import get_ai_client
from config import DEFAULT_OUTPUT_DIR, LANGUAGE_CODES, AI_PROVIDER

def get_available_backgrounds():
    """
    Get list of available background images from backgrounds/ directory.
    Returns list of background file paths, or empty list if none found.
    """
    backgrounds_dir = 'backgrounds'
    
    # Check if backgrounds directory exists
    if not os.path.exists(backgrounds_dir):
        click.echo(f"‚ö†Ô∏è  No backgrounds directory found at: {backgrounds_dir}")
        return []
    
    # Find all PNG files in backgrounds directory
    background_files = glob.glob(os.path.join(backgrounds_dir, '*.png'))
    
    if not background_files:
        click.echo(f"‚ö†Ô∏è  No PNG files found in: {backgrounds_dir}")
        return []
    
    click.echo(f"üìé Found {len(background_files)} background images")
    return background_files

def copy_background_for_document(background_files, output_dir, doc_number):
    """
    Randomly select and copy a background for a specific document.
    Returns tuple (background_filename, source_name) or (None, None) if no backgrounds available.
    """
    if not background_files:
        return None, None
    
    # Randomly select a background
    selected_background = random.choice(background_files)
    background_filename = f'background_{doc_number:04d}.png'
    destination_path = os.path.join(output_dir, background_filename)
    source_name = os.path.basename(selected_background)
    
    # Copy the selected background to output directory
    try:
        shutil.copy2(selected_background, destination_path)
        return background_filename, source_name
    except Exception as e:
        click.echo(f"‚ùå Failed to copy background for document {doc_number}: {e}")
        return None, None

@click.command()
@click.option('--entity-file', '-e', required=True,
              help='Path to JSON file containing entity data (generated by generate_entities.py)')
@click.option('--document-type', '-t', default=None,
              help='Override document type (uses document type from entity file if not specified)')
@click.option('--language', '-l', default=None,
              help=f'Override language code (uses language from entity file if not specified). Supported: {", ".join(sorted(LANGUAGE_CODES.keys()))}')
@click.option('--template-image', '-i', type=click.Path(exists=True), default=None,
              help='Path to image file to use as template for document layout and structure')
@click.option('--output-dir', '-o', default=DEFAULT_OUTPUT_DIR,
              help=f'Output directory for HTML documents (default: {DEFAULT_OUTPUT_DIR})')
@click.option('--start-index', '-s', default=1, type=int,
              help='Starting index for document numbering (default: 1)')
def generate_documents(entity_file, document_type, language, template_image, output_dir, start_index):
    """
    Generate HTML documents using pre-generated entity data.
    
    This command reads entity data from a JSON file (created by generate_entities.py)
    and generates HTML documents using that data.
    
    Examples:
    
    python generate_documents.py -e output/entity_data.json
    
    python generate_documents.py -e thai_entities/entity_data.json -o contracts
    
    python generate_documents.py -e output/entity_data.json -t "custom document type" -l en
    
    python generate_documents.py -e output/entity_data.json -i template.jpg -o templated_docs
    """
    
    # Validate entity file exists
    if not os.path.exists(entity_file):
        click.echo(f"Error: Entity file not found: {entity_file}")
        return 1
    
    # Load entity data
    try:
        with open(entity_file, 'r', encoding='utf-8') as f:
            entity_data_list = json.load(f)
    except json.JSONDecodeError:
        click.echo(f"Error: Invalid JSON in entity file: {entity_file}")
        return 1
    except Exception as e:
        click.echo(f"Error reading entity file: {e}")
        return 1
    
    if not isinstance(entity_data_list, list):
        click.echo("Error: Entity file must contain a JSON array")
        return 1
    
    if not entity_data_list:
        click.echo("Error: Entity file contains no data")
        return 1
    
    # Extract document type and language from entity data if not provided
    first_entity = entity_data_list[0]
    
    # Use document type from entity data if not overridden
    if document_type is None:
        if '_document_type' in first_entity:
            document_type = first_entity['_document_type']
        else:
            click.echo("Error: No document type found in entity data and none provided via -t option")
            return 1
    
    # Use language from entity data if not overridden
    if language is None:
        if '_language' in first_entity:
            language = first_entity['_language']
        else:
            language = 'en'  # Default fallback
    
    # Validate language code
    if language not in LANGUAGE_CODES:
        click.echo(f"Error: Unsupported language code '{language}'")
        click.echo(f"Supported language codes: {', '.join(sorted(LANGUAGE_CODES.keys()))}")
        return 1
    
    # Create output directory
    os.makedirs(output_dir, exist_ok=True)
    
    # Display configuration
    click.echo(f"Document Type: {document_type}")
    click.echo(f"Entity File: {entity_file}")
    click.echo(f"Entity Records: {len(entity_data_list)}")
    click.echo(f"Language: {language}")
    if template_image:
        click.echo(f"Template Image: {template_image}")
    click.echo(f"Output Directory: {output_dir}")
    click.echo(f"Starting Index: {start_index}")
    click.echo()
    
    try:
        # Get available background images
        background_files = get_available_backgrounds()
        
        # Generate HTML documents
        # Use the AI provider system for flexibility
        client = get_ai_client(provider=AI_PROVIDER)
        generated_documents = []
        
        click.echo(f"Generating {len(entity_data_list)} HTML documents...")
        
        for i, entity_data in enumerate(entity_data_list):
            # Calculate document number
            doc_number = start_index + i
            
            # Select and copy a random background for this document
            background_filename, source_name = copy_background_for_document(background_files, output_dir, doc_number)
            
            # Generate document with specific entity data
            complete_html = client.generate_document_with_data(
                document_type, entity_data, language, template_image
            )
            
            # Add background styling and UTF-8 support
            if background_filename:
                # Inject background styling into existing HTML
                if complete_html.startswith('<style'):
                    # Find the end of the existing style tag and inject background styles
                    style_end = complete_html.find('</style>')
                    if style_end != -1:
                        background_styles = f"""
  body, html {{
    background-image: url('./{background_filename}');
    background-size: cover;
    background-position: center;
    background-repeat: no-repeat;
    background-attachment: fixed;
    min-height: 100vh;
  }}
  * {{
    font-family: Arial, 'Segoe UI', 'DejaVu Sans', 'Helvetica Neue', Helvetica, sans-serif !important;
  }}"""
                        # Insert background styles before the closing </style> tag
                        complete_html = complete_html[:style_end] + background_styles + complete_html[style_end:]
                else:
                    # Add new style block if no existing styles
                    style_parts = [
                        "* {",
                        "    font-family: Arial, 'Segoe UI', 'DejaVu Sans', 'Helvetica Neue', Helvetica, sans-serif !important;",
                        "}",
                        "body, html {",
                        f"    background-image: url('./{background_filename}');",
                        "    background-size: cover;",
                        "    background-position: center;",
                        "    background-repeat: no-repeat;",
                        "    background-attachment: fixed;",
                        "    min-height: 100vh;",
                        "}"
                    ]
                    font_style = f"<style>\n{chr(10).join(style_parts)}\n</style>\n"
                    complete_html = font_style + complete_html
            else:
                # Just add UTF-8 font support if no background
                if not complete_html.startswith('<style'):
                    font_style = "<style>\n* {\n    font-family: Arial, 'Segoe UI', 'DejaVu Sans', 'Helvetica Neue', Helvetica, sans-serif !important;\n}\n</style>\n"
                    complete_html = font_style + complete_html
            
            # Save HTML file with UTF-8 encoding - use document type for filename
            # Create a safe filename from document type by replacing spaces and special chars
            safe_doc_type = document_type.lower().replace(' ', '_').replace('-', '_')
            # Remove any other special characters that might cause issues
            safe_doc_type = ''.join(c for c in safe_doc_type if c.isalnum() or c == '_')
            filename = f"{safe_doc_type}_{doc_number:04d}.html"
            filepath = os.path.join(output_dir, filename)
            
            with open(filepath, 'w', encoding='utf-8', newline='') as f:
                f.write(complete_html)
            
            # Track generated document
            generated_documents.append({
                'filename': filename,
                'document_type': document_type,
                'language': language,
                'entity_data': entity_data
            })
            
            if source_name:
                click.echo(f"Generated: {filename} (background: {source_name})")
            else:
                click.echo(f"Generated: {filename} (no background)")
        
        # Save document metadata JSON
        metadata_filepath = os.path.join(output_dir, 'document_metadata.json')
        with open(metadata_filepath, 'w', encoding='utf-8') as f:
            json.dump(generated_documents, f, indent=2, ensure_ascii=False)
        
        click.echo(f"‚úÖ Successfully generated {len(entity_data_list)} documents!")
        click.echo(f"üìÅ HTML files saved to: {os.path.abspath(output_dir)}")
        click.echo(f"üìÑ Document metadata saved to: {os.path.abspath(metadata_filepath)}")
        
    except Exception as e:
        click.echo(f"‚ùå Error: {str(e)}")
        return 1

if __name__ == '__main__':
    generate_documents()